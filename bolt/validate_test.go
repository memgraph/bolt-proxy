package bolt

import (
	"bytes"
	"testing"
)

func TestParsingReadMode(t *testing.T) {
	// BEGIN { "mode": "r" }
	buf := []byte{0x00, 0x0a, 0xb1, 0x11, 0xa1, 0x84, 0x6d, 0x6f, 0x64, 0x65, 0x81, 0x72, 0x0, 0x0}

	mode, err := ValidateMode(buf)
	if err != nil {
		t.Fatalf("failed to parse mode: %v", err)
	}
	if mode != ReadMode {
		t.Fatalf("expected to see a read mode")
	}
}

func TestParsingEmptyMode(t *testing.T) {
	// BEGIN { }
	buf := []byte{0x00, 0x03, 0xb1, 0x11, 0xa0, 0x0, 0x0}

	mode, err := ValidateMode(buf)
	if err != nil {
		t.Fatalf("failed to parse mode: %v", err)
	}
	if mode != WriteMode {
		t.Fatalf("expected to see a write mode")
	}
}

func TestParsingFailure(t *testing.T) {
	// FAILURE {'code': 'Neo.ClientError.Security.Unauthorized',
	// 'message': 'The client is unauthorized due to authentication failure.'}
	buf := []byte{
		0xa2, 0x84, 0x63, 0x6f, 0x64, 0x65, 0xd0, 0x25,
		0x4e, 0x65, 0x6f, 0x2e, 0x43, 0x6c, 0x69, 0x65,
		0x6e, 0x74, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x2e,
		0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
		0x2e, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x6f,
		0x72, 0x69, 0x7a, 0x65, 0x64, 0x87, 0x6d, 0x65,
		0x73, 0x73, 0x61, 0x67, 0x65, 0xd0, 0x39, 0x54,
		0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
		0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e, 0x61,
		0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65,
		0x64, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f,
		0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
		0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
		0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x2e,
		0x0, 0x0}

	result, _, err := ParseMap(buf)
	if err != nil {
		t.Fatal("failed to parse tiny map")
	}
	val, ok := result["message"]
	if !ok {
		t.Fatal("failed to find 'message' in tiny map")
	}
	msg, ok := val.(string)
	if !ok {
		t.Fatalf("expected a string value, saw: %v", val)
	}
	if msg != "The client is unauthorized due to authentication failure." {
		t.Fatal("unexpected message:", val)
	}
}

func TestValidateHandshake(t *testing.T) {
	v42s := []byte{0x0, 0x0, 0x2, 0x4}
	v41s := []byte{0x0, 0x0, 0x1, 0x4}
	v40s := []byte{0x0, 0x0, 0x0, 0x4}
	v35s := []byte{0x0, 0x0, 0x5, 0x3}

	// Client handshakes
	v42c := []byte{
		0x0, 0x0, 0x2, 0x04,
		0x0, 0x0, 0x1, 0x04,
		0x0, 0x0, 0x0, 0x4,
		0x0, 0x0, 0x5, 0x3,
	}
	v41c := []byte{
		0x0, 0x0, 0x1, 0x04,
		0x0, 0x0, 0x0, 0x04,
		0x0, 0x0, 0x5, 0x3,
		0x0, 0x0, 0x0, 0x3,
	}
	v40c := []byte{
		0x0, 0x0, 0x0, 0x04,
		0x0, 0x0, 0x5, 0x03,
		0x0, 0x0, 0x0, 0x3,
		0x0, 0x0, 0x0, 0x2,
	}
	v35c := []byte{
		0x0, 0x0, 0x5, 0x03,
		0x0, 0x0, 0x0, 0x03,
		0x0, 0x0, 0x0, 0x2,
		0x0, 0x0, 0x0, 0x1,
	}

	// tests: [client, server, expected]
	tests := []map[string][]byte{
		{"client": v42c, "server": v42s, "expected": v42s},
		{"client": v41c, "server": v42s, "expected": v41s},
		{"client": v40c, "server": v42s, "expected": v40s},
		{"client": v42c, "server": v40s, "expected": v40s},
		{"client": v35c, "server": v42s, "expected": v35s},
		{"client": v41c, "server": v40s, "expected": v40s},
	}

	for _, test := range tests {
		result, err := ValidateHandshake(test["client"], test["server"])
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(test["expected"], result) {
			t.Fatalf("expected %#v, got %#v (test: %#v)\n", test["expected"], result, test)
		}
	}
}
